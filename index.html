<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PotaKB Keymap Configurator (Mobile)</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif; 
            margin: 0;
            padding: 10px;
            background-color: #f4f4f9;
            overflow-x: hidden;
        }
        
        /* „Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„É¨„Ç§„Ç¢„Ç¶„Éà */
        #top-panel { 
            display: flex; 
            gap: 15px; 
            width: 100%; 
            flex-wrap: wrap; 
        }
        
        .config-section { 
            border: 1px solid #ccc; 
            padding: 15px; 
            border-radius: 8px; 
            background-color: #fff; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }
        
        #keyboard-area { flex: 1 1 780px; min-width: 300px; }
        #settings-area { flex: 0 0 280px; min-width: 280px; }
        
        /* „É¢„Éê„Ç§„É´ÂØæÂøú */
        @media (max-width: 768px) {
            body { padding: 5px; }
            
            #top-panel { 
                flex-direction: column;
                gap: 10px;
            }
            
            #keyboard-area, #settings-area {
                flex: 1 1 auto;
                min-width: 100%;
                width: 100%;
            }
            
            .config-section {
                padding: 10px;
            }
            
            h2 { font-size: 18px; margin: 0 0 10px 0; }
            h4 { font-size: 16px; margin: 10px 0 8px 0; }
            
            /* „Ç≠„Éº„Éú„Éº„Éâ„ÇíÊ®™„Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩ„Å´ */
            #keyboard-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding: 5px;
            }
            
            /* „Ç≠„Éº„ÅÆ„Çµ„Ç§„Ç∫„ÇíË™øÊï¥ */
            .key-row { height: 36px; margin-bottom: 4px; }
            .key { 
                height: 34px; 
                font-size: 9px;
                min-width: 34px;
            }
            .key-name { font-size: 7px; }
            
            /* „Éë„É¨„ÉÉ„Éà„ÅÆ„Éú„Çø„É≥„ÇíÂ§ß„Åç„Åè */
            .palette-key {
                padding: 8px 10px;
                font-size: 13px;
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .palette-keys {
                gap: 8px;
            }
            
            /* „Çø„Éñ„Éú„Çø„É≥„ÇíÂ§ß„Åç„Åè */
            .tab-button {
                padding: 12px 10px;
                font-size: 13px;
                flex: 1;
            }
            
            #tab-buttons-container {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            
            /* „Éú„Çø„É≥„Çí„Çø„ÉÉ„ÉÅ„Åó„ÇÑ„Åô„Åè */
            button, label[for="file-importer"] {
                padding: 14px 15px;
                font-size: 15px;
                min-height: 48px;
            }
            
            input[type="number"] {
                font-size: 16px;
                padding: 8px;
            }
            
            /* Ë®≠ÂÆöÈ†ÖÁõÆ„ÇíÁ∏¶‰∏¶„Å≥„Å´ */
            .setting-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .setting-item input {
                width: 100%;
                margin-left: 0;
            }
            
            /* Êé•Á∂ö„Çø„Éñ */
            .connection-tabs {
                flex-direction: column;
            }
            
            .connection-tab {
                padding: 12px;
                font-size: 14px;
            }
            
            /* „Éò„É´„Éó„ÉÜ„Ç≠„Çπ„Éà */
            .bt-help {
                font-size: 12px;
            }
        }
        
        /* Ë∂ÖÂ∞èÂûã„Çπ„Éû„ÉõÂØæÂøú */
        @media (max-width: 380px) {
            .key { 
                height: 30px; 
                font-size: 8px;
                min-width: 30px;
            }
            .key-row { height: 32px; }
            .key-name { font-size: 6px; }
        }
        
        #keyboard-container { padding: 10px; }
        .key-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; position: relative; height: 44px; }
        .key { height: 42px; border: 1px solid #aaa; border-radius: 5px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 11px; cursor: pointer; background-color: #f0f0f0; user-select: none; transition: all 0.2s; box-shadow: 0 2px 0 #ccc; flex-shrink: 0; }
        .key:hover, .key:active { background-color: #dcedff; border-color: #007bff; }
        .key.selected { border-color: #dc3545; background-color: #f8d7da; box-shadow: 0 2px 0 #e49197; outline: 2px solid #dc3545; }
        .key.waiting-capture { background-color: #d4edda; border-color: #28a745; outline: 2px solid #28a745; box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); }
        .key-name { font-size: 8px; color: #666; }
        .key-code { font-weight: bold; }
        #tab-buttons-container { border-bottom: 1px solid #dee2e6; margin-bottom: 10px; }
        .tab-button { background: none; border: none; padding: 10px 15px; cursor: pointer; font-size: 14px; border-radius: 5px 5px 0 0; margin-bottom: -1px; }
        .tab-button.active { background-color: #fff; border: 1px solid #dee2e6; border-bottom: 1px solid #fff; font-weight: bold; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .palette-keys { display: flex; flex-wrap: wrap; gap: 5px; }
        .palette-key { padding: 5px 8px; font-size: 12px; background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer; }
        .palette-key:hover, .palette-key:active { background-color: #007bff; color: white; border-color: #0056b3; }
        .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        #settings-container input { width: 60px; text-align: right; margin-left: 10px; }
        button, label[for="file-importer"] { padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; font-size: 14px; margin-top: 5px; }
        #generate-button { background-color: #5a6268; color: white; width: 100%; }
        label[for="file-importer"] { background-color: #6c757d; color: white; display: block; text-align: center; margin-bottom: 10px; }
        #connect-button, #connect-usb-button { background-color: #007bff; color: white; width: 100%; margin-bottom: 5px; }
        #save-to-keyboard-button { background-color: #28a745; color: white; width: 100%; margin-top: 10px; }
        #load-from-keyboard-button { background-color: #17a2b8; color: white; width: 100%; margin-top: 5px; }
        #connection-status { margin-top: 10px; font-size: 12px; text-align: center; padding: 8px; border-radius: 4px; background-color: #f8f9fa; }
        #battery-info { margin-top: 5px; font-size: 12px; text-align: center; padding: 8px; border-radius: 4px; background-color: #d4edda; }
        input[type="file"] { display: none; }
        .bt-help { font-size: 11px; color: #666; margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; }
        .debug-info { font-size: 10px; color: #999; margin-top: 5px; padding: 5px; background-color: #f0f0f0; border-radius: 3px; max-height: 100px; overflow-y: auto; }
        #palette-description { font-style: italic; color: #555; margin-top: 10px; margin-bottom: 10px; font-size: 13px; }
        #key-description { min-height: 1.2em; font-size: 12px; color: #333; background-color: #f8f9fa; padding: 5px 8px; border-radius: 4px; margin-top: 10px; }
        .connection-tabs { display: flex; gap: 5px; margin-bottom: 10px; }
        .connection-tab { flex: 1; padding: 8px; background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer; text-align: center; font-size: 12px; }
        .connection-tab.active { background-color: #007bff; color: white; border-color: #0056b3; }
        #palette-area { margin-top: 20px; border-top: 2px solid #dee2e6; padding-top: 15px; }
    </style>
</head>
<body>
    <div id="top-panel">
        <div id="keyboard-area" class="config-section">
            <h2>PotaKB Layout Editor</h2>
            <div>
                Layer: <select id="layer-selector"><option value="0">Default</option><option value="1">Lower</option></select>
                <label style="margin-left: 20px; font-size: 12px;">
                    <input type="checkbox" id="jis-layout-toggle"> Êó•Êú¨Ë™ûÈÖçÂàó„ÅßË°®Á§∫
                </label>
                <small style="display: block; margin-top: 5px;">(„Ç≠„Éº„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Áâ©ÁêÜ„Ç≠„Éº„ÇíÊäº„Åô„Å®„ÄÅ„Ç≠„Éº„Ç≥„Éº„Éâ„ÇíÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Åæ„Åô)</small>
            </div>
            <div id="keyboard-container"></div>
            
            <div id="palette-area">
                <h4>Keycode Palette <small>(Click a key on the layout, then click a button below)</small></h4>
                <p id="palette-description"></p>
                <div id="tab-buttons-container"></div>
                <div id="tab-content-container"></div>
                <p id="key-description">&nbsp;</p>
            </div>
        </div>
        
        <div id="settings-area" class="config-section">
            <h4>File & Settings</h4>
            <input type="file" id="file-importer" accept=".h">
            <label for="file-importer">Load keymap.h</label>
            <button id="generate-button">Download keymap.h</button>
            <hr>
            <h4>Device Connection</h4>
            <div class="connection-tabs">
                <div class="connection-tab active" data-type="bluetooth">Bluetooth</div>
                <div class="connection-tab" data-type="usb">USB Serial</div>
            </div>
            <div id="bluetooth-section">
                <button id="connect-button">Connect via Bluetooth</button>
            </div>
            <div id="usb-section" style="display: none;">
                <button id="connect-usb-button">Connect via USB Serial</button>
            </div>
            <button id="load-from-keyboard-button" disabled>Load from Keyboard</button>
            <button id="save-to-keyboard-button" disabled>Save to Keyboard</button>
            <div id="connection-status">Status: Disconnected</div>
            <div id="battery-info">üîã Battery: --</div>
            <div class="bt-help">
                <strong>Êé•Á∂ö„Åß„Åç„Å™„ÅÑÂ†¥Âêà:</strong><br>
                <span id="bt-help-text">
                1. „Ç≠„Éº„Éú„Éº„Éâ„ÅÆÈõªÊ∫ê„ÇíÂÖ•„ÇåÁõ¥„Åô<br>
                2. Bluetooth„É¢„Éº„Éâ„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç<br>
                3. ‰ªñ„ÅÆ„Éá„Éê„Ç§„Çπ„Å®Êé•Á∂ö„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç<br>
                4. „Éñ„É©„Ç¶„Ç∂„ÅØChrome/Edge„Çí‰ΩøÁî®<br>
                5. HTTPS„ÅßÈñã„ÅÑ„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
                </span>
                <span id="usb-help-text" style="display: none;">
                1. USB„Ç±„Éº„Éñ„É´„Åß„Ç≠„Éº„Éú„Éº„Éâ„ÇíÊé•Á∂ö<br>
                2. „Éñ„É©„Ç¶„Ç∂„ÅØChrome/Edge„Çí‰ΩøÁî®<br>
                3. ÂøÖË¶Å„Å´Âøú„Åò„Å¶„Ç∑„É™„Ç¢„É´„Éù„Éº„ÉàË®±ÂèØ„ÇíÁ¢∫Ë™ç
                </span>
                <hr style="margin: 8px 0;">
                <strong>ÁâπÊÆä„Å™„Ç≠„Éº„Å´„Å§„ÅÑ„Å¶:</strong><br>
                - <strong>Mode:</strong> USB/BTÊé•Á∂ö„ÇíÂàá„ÇäÊõø„Åà„ÇãÂøÖÈ†à„Ç≠„Éº„Åß„Åô„ÄÇ<br>
                - <strong>Reset KM:</strong> ‰øùÂ≠ò„Åï„Çå„Åü„Ç≠„Éº„Éû„ÉÉ„Éó„ÇíÂÆåÂÖ®„Å´Ê∂àÂéª„Åó„Å¶ÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ<br>
                - <strong>Boot DEF:</strong> „Ç≠„Éº„Éû„ÉÉ„Éó„ÇíÊ∂à„Åï„Åö„Å´„ÄÅ‰∏ÄÊôÇÁöÑ„Å´ÂàùÊúüË®≠ÂÆö„ÅßÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ
            </div>
            <div class="debug-info" id="debug-log"></div>
            <hr>
            <div id="settings-container">
                <div class="setting-item"><label>MOUSE_HIGH_SPEED:</label><input type="number" step="0.1" id="MOUSE_HIGH_SPEED"></div>
                <div class="setting-item"><label>MOUSE_LOW_SPEED:</label><input type="number" step="0.1" id="MOUSE_LOW_SPEED"></div>
                <div class="setting-item"><label>MOUSE_ACCEL_THRESHOLD:</label><input type="number" id="MOUSE_ACCEL_THRESHOLD"></div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const KEYCODES = { "Special": ["KC_NO", "KC_TRNS", "L_LOWER", "SW_USB_BT", "KC_RESET_KM", "KC_REBOOT_DEF"], "Alphabet": [...Array(26)].map((_, i) => `HID_KEY_${String.fromCharCode(65 + i)}`), "Numbers": [...Array(10)].map((_, i) => `HID_KEY_${(i + 1) % 10}`), "Function": [...Array(12)].map((_, i) => `HID_KEY_F${i + 1}`), "Modifiers": ["HID_KEY_CONTROL_LEFT", "HID_KEY_SHIFT_LEFT", "HID_KEY_ALT_LEFT", "HID_KEY_GUI_LEFT", "HID_KEY_CONTROL_RIGHT", "HID_KEY_SHIFT_RIGHT", "HID_KEY_ALT_RIGHT", "HID_KEY_GUI_RIGHT"], "Control & Whitespace": ["HID_KEY_ENTER", "HID_KEY_ESCAPE", "HID_KEY_BACKSPACE", "HID_KEY_DELETE", "HID_KEY_TAB", "HID_KEY_SPACE", "HID_KEY_APPLICATION", "HID_KEY_CAPS_LOCK"], "Navigation": ["HID_KEY_ARROW_RIGHT", "HID_KEY_ARROW_LEFT", "HID_KEY_ARROW_DOWN", "HID_KEY_ARROW_UP", "HID_KEY_INSERT", "HID_KEY_HOME", "HID_KEY_END", "HID_KEY_PAGE_UP", "HID_KEY_PAGE_DOWN", "HID_KEY_PRINT_SCREEN", "HID_KEY_SCROLL_LOCK", "HID_KEY_PAUSE"], "Symbols (US)": ["HID_KEY_MINUS", "HID_KEY_EQUAL", "HID_KEY_BRACKET_LEFT", "HID_KEY_BRACKET_RIGHT", "HID_KEY_BACKSLASH", "HID_KEY_SEMICOLON", "HID_KEY_APOSTROPHE", "HID_KEY_GRAVE", "HID_KEY_COMMA", "HID_KEY_PERIOD", "HID_KEY_SLASH"], "JP Layout": ["HID_KEY_LANG1", "HID_KEY_LANG2", "HID_KEY_INTERNATIONAL1", "HID_KEY_INTERNATIONAL3"], "Mouse": ["KC_MS_BTN1", "KC_MS_BTN2", "KC_MS_BTN3", "KC_MS_BTN4", "KC_MS_BTN5", "KC_MS_UP", "KC_MS_DOWN", "KC_MS_LEFT", "KC_MS_RIGHT"] };
    const CATEGORY_DESCRIPTIONS = { "Special": "„É¨„Ç§„É§„ÉºÂàá„ÇäÊõø„Åà„ÇÑ„É¢„Éº„ÉâÂ§âÊõ¥„ÄÅ„Éó„É≠„Éï„Ç°„Ç§„É´„É™„Çª„ÉÉ„Éà„Å™„Å©„ÄÅ„Ç≠„Éº„Éú„Éº„Éâ„ÅÆÁâπÊÆäÊ©üËÉΩ„ÇíÂà∂Âæ°„Åó„Åæ„Åô„ÄÇ", "Alphabet": "A„Åã„ÇâZ„Åæ„Åß„ÅÆ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„Ç≠„Éº„Åß„Åô„ÄÇ", "Numbers": "0„Åã„Çâ9„Åæ„Åß„ÅÆÊï∞Â≠ó„Ç≠„Éº„Åß„Åô„ÄÇ", "Function": "F1„Åã„ÇâF12„Åæ„Åß„ÅÆ„Éï„Ç°„É≥„ÇØ„Ç∑„Éß„É≥„Ç≠„Éº„Åß„Åô„ÄÇ", "Modifiers": "Ctrl„ÄÅShift„ÄÅAlt„ÄÅGUI (Windows/Command) „Å™„Å©„ÅÆ‰øÆÈ£æ„Ç≠„Éº„Åß„Åô„ÄÇ", "Control & Whitespace": "Enter„ÄÅEsc„ÄÅ„Çπ„Éö„Éº„Çπ„Ç≠„Éº„Å™„Å©„ÄÅÂÖ•ÂäõÂà∂Âæ°„ÇÑÁ©∫ÁôΩ„Å´Èñ¢ÈÄ£„Åô„Çã„Ç≠„Éº„Åß„Åô„ÄÇ", "Navigation": "Áü¢Âç∞„Ç≠„Éº„ÇÑHome„ÄÅEnd„Å™„Å©„ÄÅ„Ç´„Éº„ÇΩ„É´ÁßªÂãï„ÇÑ„Éö„Éº„Ç∏Êìç‰Ωú„ÇíË°å„ÅÜ„Ç≠„Éº„Åß„Åô„ÄÇ", "Symbols (US)": "USÈÖçÂàó„Å´„Åä„Åë„Çã‰∏ÄËà¨ÁöÑ„Å™Ë®òÂè∑„Ç≠„Éº„Åß„Åô„ÄÇ (, ; [ ]„Å™„Å©)", "JP Layout": "Êó•Êú¨Ë™ûÈÖçÂàóÁâπÊúâ„ÅÆ„Ç≠„Éº„Åß„Åô„ÄÇ(ÂçäËßí/ÂÖ®Ëßí„ÄÅÁÑ°Â§âÊèõ„ÄÅÂ§âÊèõ„ÄÅ„Ç´„Çø„Ç´„Éä„Å≤„Çâ„Åå„Å™Á≠â)", "Mouse": "„Éû„Ç¶„Çπ„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„ÇÑ„Ç´„Éº„ÇΩ„É´ÁßªÂãï„Çí„Ç≠„Éº„Å´Ââ≤„ÇäÂΩì„Å¶„Åæ„Åô„ÄÇ" };
    const KEYCODE_DESCRIPTIONS = { "KC_NO": "No Action: „Åì„ÅÆ„Ç≠„Éº„ÇíÊäº„Åó„Å¶„ÇÇ‰Ωï„ÇÇËµ∑„Åì„Çä„Åæ„Åõ„Çì„ÄÇ", "KC_TRNS": "Transparent: ‰∏ã„ÅÆ„É¨„Ç§„É§„Éº„ÅÆ„Ç≠„Éº„ÇíÈÄèÈÅé„Åï„Åõ„Åæ„Åô„ÄÇ („É¨„Ç§„É§„Éº1‰ª•‰∏ä„ÅßÊúâÂäπ)", "L_LOWER": "Lower Layer: Êäº„Åó„Å¶„ÅÑ„ÇãÈñì„ÄÅ„É¨„Ç§„É§„Éº1 (Lower) „Å´Âàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ", "SW_USB_BT": "Mode Switch: USBÊé•Á∂ö„Å®BluetoothÊé•Á∂ö„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ", "KC_RESET_KM": "Reset Keymap: ‰øùÂ≠ò„Åï„Çå„Åü„Ç´„Çπ„Çø„É†„Ç≠„Éº„Éû„ÉÉ„Éó„ÇíÂÆåÂÖ®„Å´Ê∂àÂéª„Åó„ÄÅÂàùÊúüÁä∂ÊÖã„ÅßÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ", "KC_REBOOT_DEF": "Reboot to Default: „Ç´„Çπ„Çø„É†„Ç≠„Éº„Éû„ÉÉ„Éó„ÇíÁ∂≠ÊåÅ„Åó„Åü„Åæ„Åæ„ÄÅ‰∏ÄÊôÇÁöÑ„Å´ÂàùÊúüË®≠ÂÆö„ÅßÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ", "HID_KEY_LANG1": "ÂçäËßí/ÂÖ®Ëßí„ÉªÊº¢Â≠ó„Ç≠„Éº (JP)", "HID_KEY_LANG2": "„Ç´„Çø„Ç´„Éä„Éª„Å≤„Çâ„Åå„Å™„Éª„É≠„Éº„ÉûÂ≠ó„Ç≠„Éº (JP)", "HID_KEY_INTERNATIONAL1": "¬•„Ç≠„Éº (JP)", "HID_KEY_INTERNATIONAL3": "_ („Ç¢„É≥„ÉÄ„Éº„Çπ„Ç≥„Ç¢) „Ç≠„Éº (JP)" };
    const JIS_KEY_MAP = { 'HID_KEY_GRAVE': 'Âçä/ÂÖ®', 'HID_KEY_MINUS': '„Éº', 'HID_KEY_EQUAL': '^', 'HID_KEY_BRACKET_LEFT': '@', 'HID_KEY_BRACKET_RIGHT': '[', 'HID_KEY_BACKSLASH': ']', 'HID_KEY_SEMICOLON': ';', 'HID_KEY_APOSTROPHE': ':', 'HID_KEY_INTERNATIONAL1': '¬•', 'HID_KEY_INTERNATIONAL3': '\\' };
    const EVENT_CODE_TO_KEYCODE_MAP = { 'KeyA':'HID_KEY_A','KeyB':'HID_KEY_B','KeyC':'HID_KEY_C','KeyD':'HID_KEY_D','KeyE':'HID_KEY_E','KeyF':'HID_KEY_F','KeyG':'HID_KEY_G','KeyH':'HID_KEY_H','KeyI':'HID_KEY_I','KeyJ':'HID_KEY_J','KeyK':'HID_KEY_K','KeyL':'HID_KEY_L','KeyM':'HID_KEY_M','KeyN':'HID_KEY_N','KeyO':'HID_KEY_O','KeyP':'HID_KEY_P','KeyQ':'HID_KEY_Q','KeyR':'HID_KEY_R','KeyS':'HID_KEY_S','KeyT':'HID_KEY_T','KeyU':'HID_KEY_U','KeyV':'HID_KEY_V','KeyW':'HID_KEY_W','KeyX':'HID_KEY_X','KeyY':'HID_KEY_Y','KeyZ':'HID_KEY_Z', 'Digit1':'HID_KEY_1','Digit2':'HID_KEY_2','Digit3':'HID_KEY_3','Digit4':'HID_KEY_4','Digit5':'HID_KEY_5','Digit6':'HID_KEY_6','Digit7':'HID_KEY_7','Digit8':'HID_KEY_8','Digit9':'HID_KEY_9','Digit0':'HID_KEY_0', 'F1':'HID_KEY_F1','F2':'HID_KEY_F2','F3':'HID_KEY_F3','F4':'HID_KEY_F4','F5':'HID_KEY_F5','F6':'HID_KEY_F6','F7':'HID_KEY_F7','F8':'HID_KEY_F8','F9':'HID_KEY_F9','F10':'HID_KEY_F10','F11':'HID_KEY_F11','F12':'HID_KEY_F12', 'Enter':'HID_KEY_ENTER','Escape':'HID_KEY_ESCAPE','Backspace':'HID_KEY_BACKSPACE','Tab':'HID_KEY_TAB','Space':'HID_KEY_SPACE','Minus':'HID_KEY_MINUS','Equal':'HID_KEY_EQUAL','BracketLeft':'HID_KEY_BRACKET_LEFT','BracketRight':'HID_KEY_BRACKET_RIGHT','Backslash':'HID_KEY_BACKSLASH','Semicolon':'HID_KEY_SEMICOLON','Quote':'HID_KEY_APOSTROPHE','Backquote':'HID_KEY_GRAVE','Comma':'HID_KEY_COMMA','Period':'HID_KEY_PERIOD','Slash':'HID_KEY_SLASH', 'CapsLock':'HID_KEY_CAPS_LOCK','ScrollLock':'HID_KEY_SCROLL_LOCK','Pause':'HID_KEY_PAUSE','Insert':'HID_KEY_INSERT','Home':'HID_KEY_HOME','PageUp':'HID_KEY_PAGE_UP','Delete':'HID_KEY_DELETE','End':'HID_KEY_END','PageDown':'HID_KEY_PAGE_DOWN', 'ArrowRight':'HID_KEY_ARROW_RIGHT','ArrowLeft':'HID_KEY_ARROW_LEFT','ArrowDown':'HID_KEY_ARROW_DOWN','ArrowUp':'HID_KEY_ARROW_UP', 'ControlLeft':'HID_KEY_CONTROL_LEFT','ShiftLeft':'HID_KEY_SHIFT_LEFT','AltLeft':'HID_KEY_ALT_LEFT','MetaLeft':'HID_KEY_GUI_LEFT', 'ControlRight':'HID_KEY_CONTROL_RIGHT','ShiftRight':'HID_KEY_SHIFT_RIGHT','AltRight':'HID_KEY_ALT_RIGHT','MetaRight':'HID_KEY_GUI_RIGHT', 'IntlYen': 'HID_KEY_INTERNATIONAL1', 'IntlRo': 'HID_KEY_INTERNATIONAL3' };
    const physical_layout_order_name = [ "sw1", "sw62", "sw2", "sw5", "sw9", "sw13", "sw17", "sw21", "sw25", "sw30", "sw35", "sw40", "sw45", "sw50", "sw55", "sw59", "sw63", "sw3", "sw6", "sw10", "sw14", "sw18", "sw22", "sw26", "sw31", "sw36", "sw41", "sw46", "sw51", "sw56", "sw60", "sw4", "sw7", "sw11", "sw15", "sw19", "sw23", "sw27", "sw32", "sw37", "sw42", "sw47", "sw52", "sw57", "sw61", "sw8", "sw12", "sw16", "sw20", "sw24", "sw28", "sw33", "sw38", "sw43", "sw48", "sw53", "sw58", "sw29", "sw34", "sw39", "sw44", "sw49", "sw54", "D10", "D6" ];
    
    let keymapData = [
      [ 'KC_MS_BTN1', 'KC_MS_BTN2', 'HID_KEY_ESCAPE', 'HID_KEY_1', 'HID_KEY_2', 'HID_KEY_3', 'HID_KEY_4', 'HID_KEY_5', 'HID_KEY_6', 'HID_KEY_7', 'HID_KEY_8', 'HID_KEY_9', 'HID_KEY_0', 'HID_KEY_MINUS', 'HID_KEY_EQUAL', 'HID_KEY_INTERNATIONAL1', 'HID_KEY_DELETE', 'HID_KEY_GRAVE', 'HID_KEY_Q', 'HID_KEY_W', 'HID_KEY_E', 'HID_KEY_R', 'HID_KEY_T', 'HID_KEY_Y', 'HID_KEY_U', 'HID_KEY_I', 'HID_KEY_O', 'HID_KEY_P', 'HID_KEY_BRACKET_LEFT', 'HID_KEY_BRACKET_RIGHT', 'HID_KEY_BACKSPACE', 'HID_KEY_TAB', 'HID_KEY_A', 'HID_KEY_S', 'HID_KEY_D', 'HID_KEY_F', 'HID_KEY_G', 'HID_KEY_H', 'HID_KEY_J', 'HID_KEY_K', 'HID_KEY_L', 'HID_KEY_SEMICOLON', 'HID_KEY_APOSTROPHE', 'HID_KEY_BACKSLASH', 'HID_KEY_ENTER', 'HID_KEY_Z', 'HID_KEY_X', 'HID_KEY_C', 'HID_KEY_V', 'HID_KEY_B', 'HID_KEY_N', 'HID_KEY_M', 'HID_KEY_COMMA', 'HID_KEY_PERIOD', 'HID_KEY_SLASH', 'HID_KEY_INTERNATIONAL3', 'HID_KEY_SHIFT_LEFT', 'HID_KEY_SPACE', 'HID_KEY_GUI_LEFT', 'HID_KEY_ALT_LEFT', 'HID_KEY_CONTROL_LEFT', 'KC_MS_BTN3', 'L_LOWER', 'KC_MS_BTN4', 'KC_MS_BTN5'],
      [ 'KC_TRNS', 'KC_TRNS', 'SW_USB_BT', 'HID_KEY_F1', 'HID_KEY_F2', 'HID_KEY_F3', 'HID_KEY_F4', 'HID_KEY_F5', 'HID_KEY_F6', 'HID_KEY_F7', 'HID_KEY_F8', 'HID_KEY_F9', 'HID_KEY_F10', 'HID_KEY_F11', 'HID_KEY_F12', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'HID_KEY_ARROW_UP', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'HID_KEY_ARROW_LEFT', 'HID_KEY_ARROW_DOWN', 'HID_KEY_ARROW_RIGHT', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'HID_KEY_END', 'HID_KEY_HOME', 'HID_KEY_PAGE_UP', 'HID_KEY_PAGE_DOWN', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'KC_TRNS', 'L_LOWER', 'KC_RESET_KM', 'KC_REBOOT_DEF']
    ];

    const KEYCODE_DISPLAY_MAP = {'KC_MS_BTN1': 'L Click', 'KC_MS_BTN2': 'R Click', 'KC_MS_BTN3': 'M Click', 'KC_MS_BTN4': 'Back', 'KC_MS_BTN5': 'Fwd', 'KC_MS_UP': 'M Up', 'KC_MS_DOWN': 'M Down', 'KC_MS_LEFT': 'M Left', 'KC_MS_RIGHT': 'M Right', 'HID_KEY_CONTROL_LEFT': 'L Ctrl', 'HID_KEY_SHIFT_LEFT': 'L Shift', 'HID_KEY_ALT_LEFT': 'L Alt', 'HID_KEY_GUI_LEFT': 'L GUI', 'HID_KEY_CONTROL_RIGHT': 'R Ctrl', 'HID_KEY_SHIFT_RIGHT': 'R Shift', 'HID_KEY_ALT_RIGHT': 'R Alt', 'HID_KEY_GUI_RIGHT': 'R GUI', 'HID_KEY_ENTER': 'Enter', 'HID_KEY_ESCAPE': 'Esc', 'HID_KEY_BACKSPACE': 'BSPC', 'HID_KEY_DELETE': 'Del', 'HID_KEY_TAB': 'Tab', 'HID_KEY_SPACE': 'Space', 'HID_KEY_APPLICATION': 'App', 'HID_KEY_CAPS_LOCK': 'Caps', 'HID_KEY_ARROW_RIGHT': '‚Üí', 'HID_KEY_ARROW_LEFT': '‚Üê', 'HID_KEY_ARROW_DOWN': '‚Üì', 'HID_KEY_ARROW_UP': '‚Üë', 'HID_KEY_INSERT': 'Ins', 'HID_KEY_HOME': 'Home', 'HID_KEY_END': 'End', 'HID_KEY_PAGE_UP': 'PgUp', 'HID_KEY_PAGE_DOWN': 'PgDn', 'HID_KEY_PRINT_SCREEN': 'PrtSc', 'HID_KEY_SCROLL_LOCK': 'ScLk', 'HID_KEY_PAUSE': 'Pause', 'HID_KEY_MINUS': '-', 'HID_KEY_EQUAL': '=', 'HID_KEY_BRACKET_LEFT': '[', 'HID_KEY_BRACKET_RIGHT': ']', 'HID_KEY_BACKSLASH': '\\', 'HID_KEY_SEMICOLON': ';', 'HID_KEY_APOSTROPHE': "'", 'HID_KEY_GRAVE': '`', 'HID_KEY_COMMA': ',', 'HID_KEY_PERIOD': '.', 'HID_KEY_SLASH': '/', 'KC_TRNS': '‚ñΩ', 'KC_NO': '√ó', 'L_LOWER': 'Lower', 'SW_USB_BT': 'Mode', 'KC_RESET_KM': 'Reset KM', 'KC_REBOOT_DEF': 'Boot DEF', 'HID_KEY_LANG1': 'Lang1', 'HID_KEY_LANG2': 'Lang2', 'HID_KEY_INTERNATIONAL1': 'Intl1', 'HID_KEY_INTERNATIONAL3': 'Intl3'};
    const KEYCODE_TO_VALUE_MAP = { "KC_NO": 0, "KC_TRNS": 0, "HID_KEY_A": 4, "HID_KEY_B": 5, "HID_KEY_C": 6, "HID_KEY_D": 7, "HID_KEY_E": 8, "HID_KEY_F": 9, "HID_KEY_G": 10, "HID_KEY_H": 11, "HID_KEY_I": 12, "HID_KEY_J": 13, "HID_KEY_K": 14, "HID_KEY_L": 15, "HID_KEY_M": 16, "HID_KEY_N": 17, "HID_KEY_O": 18, "HID_KEY_P": 19, "HID_KEY_Q": 20, "HID_KEY_R": 21, "HID_KEY_S": 22, "HID_KEY_T": 23, "HID_KEY_U": 24, "HID_KEY_V": 25, "HID_KEY_W": 26, "HID_KEY_X": 27, "HID_KEY_Y": 28, "HID_KEY_Z": 29, "HID_KEY_1": 30, "HID_KEY_2": 31, "HID_KEY_3": 32, "HID_KEY_4": 33, "HID_KEY_5": 34, "HID_KEY_6": 35, "HID_KEY_7": 36, "HID_KEY_8": 37, "HID_KEY_9": 38, "HID_KEY_0": 39, "HID_KEY_ENTER": 40, "HID_KEY_ESCAPE": 41, "HID_KEY_BACKSPACE": 42, "HID_KEY_TAB": 43, "HID_KEY_SPACE": 44, "HID_KEY_MINUS": 45, "HID_KEY_EQUAL": 46, "HID_KEY_BRACKET_LEFT": 47, "HID_KEY_BRACKET_RIGHT": 48, "HID_KEY_BACKSLASH": 49, "HID_KEY_SEMICOLON": 51, "HID_KEY_APOSTROPHE": 52, "HID_KEY_GRAVE": 53, "HID_KEY_COMMA": 54, "HID_KEY_PERIOD": 55, "HID_KEY_SLASH": 56, "HID_KEY_CAPS_LOCK": 57, "HID_KEY_F1": 58, "HID_KEY_F2": 59, "HID_KEY_F3": 60, "HID_KEY_F4": 61, "HID_KEY_F5": 62, "HID_KEY_F6": 63, "HID_KEY_F7": 64, "HID_KEY_F8": 65, "HID_KEY_F9": 66, "HID_KEY_F10": 67, "HID_KEY_F11": 68, "HID_KEY_F12": 69, "HID_KEY_PRINT_SCREEN": 70, "HID_KEY_SCROLL_LOCK": 71, "HID_KEY_PAUSE": 72, "HID_KEY_INSERT": 73, "HID_KEY_HOME": 74, "HID_KEY_PAGE_UP": 75, "HID_KEY_DELETE": 76, "HID_KEY_END": 77, "HID_KEY_PAGE_DOWN": 78, "HID_KEY_ARROW_RIGHT": 79, "HID_KEY_ARROW_LEFT": 80, "HID_KEY_ARROW_DOWN": 81, "HID_KEY_ARROW_UP": 82, "HID_KEY_CONTROL_LEFT": 224, "HID_KEY_SHIFT_LEFT": 225, "HID_KEY_ALT_LEFT": 226, "HID_KEY_GUI_LEFT": 227, "HID_KEY_CONTROL_RIGHT": 228, "HID_KEY_SHIFT_RIGHT": 229, "HID_KEY_ALT_RIGHT": 230, "HID_KEY_GUI_RIGHT": 231, "HID_KEY_APPLICATION": 101, "HID_KEY_LANG1": 144, "HID_KEY_LANG2": 145, "HID_KEY_INTERNATIONAL1": 135, "HID_KEY_INTERNATIONAL3": 137, "KC_MS_UP": 513, "KC_MS_DOWN": 514, "KC_MS_LEFT": 515, "KC_MS_RIGHT": 516, "KC_MS_BTN1": 517, "KC_MS_BTN2": 518, "KC_MS_BTN3": 519, "KC_MS_BTN4": 520, "KC_MS_BTN5": 521, "L_LOWER": 769, "SW_USB_BT": 1025, "KC_RESET_KM": 1281, "KC_REBOOT_DEF": 1282 };
    
    const VALUE_TO_KEYCODE_MAP = {};
    for (const [key, value] of Object.entries(KEYCODE_TO_VALUE_MAP)) {
        if (value !== 0 || key === "KC_NO") {
            VALUE_TO_KEYCODE_MAP[value] = key;
        }
    }
    
    const KEYMAP_SERVICE_UUID = 'adaf0001-c332-42a8-93bd-25e905756cb8';
    const KEYMAP_CHAR_UUID = 'adaf0002-c332-42a8-93bd-25e905756cb8';
    const BATTERY_SERVICE_UUID = '0000180f-0000-1000-8000-00805f9b34fb';
    const BATTERY_CHAR_UUID = '00002a19-0000-1000-8000-00805f9b34fb';
    
    let currentLayer = 0; 
    let selectedKeyIndices = new Set(); 
    let keymapCharacteristic = null; 
    let batteryCharacteristic = null;
    let bluetoothDevice = null;
    let serialPort = null;
    let isWaitingForKeypress = false; 
    let targetKeyIndexForCapture = null;
    let connectionType = null;
    let batteryCheckInterval = null;
    
    const keyboardContainer = document.getElementById('keyboard-container');
    const layerSelector = document.getElementById('layer-selector');
    const generateButton = document.getElementById('generate-button');
    const fileImporter = document.getElementById('file-importer');
    const tabButtonsContainer = document.getElementById('tab-buttons-container');
    const tabContentContainer = document.getElementById('tab-content-container');
    const paletteDescription = document.getElementById('palette-description');
    const keyDescription = document.getElementById('key-description');
    const connectButton = document.getElementById('connect-button');
    const connectUsbButton = document.getElementById('connect-usb-button');
    const saveToKeyboardButton = document.getElementById('save-to-keyboard-button');
    const loadFromKeyboardButton = document.getElementById('load-from-keyboard-button');
    const connectionStatus = document.getElementById('connection-status');
    const batteryInfo = document.getElementById('battery-info');
    const debugLog = document.getElementById('debug-log');
    const jisLayoutToggle = document.getElementById('jis-layout-toggle');

    function addDebugLog(message) { 
        const timestamp = new Date().toLocaleTimeString(); 
        debugLog.innerHTML = `[${timestamp}] ${message}<br>` + debugLog.innerHTML; 
    }
    
    function startBatteryMonitoring() {
        if (batteryCheckInterval) {
            clearInterval(batteryCheckInterval);
        }
        
        getBatteryLevel();
        
        batteryCheckInterval = setInterval(() => {
            if (connectionType === 'bluetooth' || connectionType === 'usb') {
                getBatteryLevel();
            }
        }, 30000);
    }
    
    function stopBatteryMonitoring() {
        if (batteryCheckInterval) {
            clearInterval(batteryCheckInterval);
            batteryCheckInterval = null;
        }
    }
    
    async function getBatteryLevel() {
        if (!serialPort && !batteryCharacteristic && connectionType !== 'bluetooth') {
            return;
        }
        
        try {
            if (connectionType === 'bluetooth') {
                if (batteryCharacteristic) {
                    const batteryValue = await batteryCharacteristic.readValue();
                    const batteryLevel = batteryValue.getUint8(0);
                    batteryInfo.textContent = `üîã Battery: ${batteryLevel}%`;
                }
            } else if (connectionType === 'usb' && serialPort) {
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode('GET_BATTERY\n'));
                writer.releaseLock();
                
                const reader = serialPort.readable.getReader();
                const decoder = new TextDecoder();
                let response = '';
                const timeout = setTimeout(() => {
                    reader.cancel();
                }, 2000);
                
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        response += decoder.decode(value, { stream: true });
                        if (response.includes('BATTERY:')) {
                            clearTimeout(timeout);
                            break;
                        }
                    }
                } catch (e) {
                    addDebugLog('„Éê„ÉÉ„ÉÜ„É™„ÉºË™≠„ÅøÂèñ„Çä„Çø„Ç§„É†„Ç¢„Ç¶„Éà');
                } finally {
                    reader.releaseLock();
                }
                
                const match = response.match(/BATTERY:(\d+)/);
                if (match) {
                    const batteryLevel = parseInt(match[1]);
                    batteryInfo.textContent = `üîã Battery: ${batteryLevel}%`;
                }
            }
        } catch (error) {
            addDebugLog('„Éê„ÉÉ„ÉÜ„É™„ÉºÂèñÂæó„Ç®„É©„Éº: ' + error.message);
        }
    }
    
    document.querySelectorAll('.connection-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const type = tab.dataset.type;
            document.querySelectorAll('.connection-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            if (type === 'bluetooth') {
                document.getElementById('bluetooth-section').style.display = 'block';
                document.getElementById('usb-section').style.display = 'none';
                document.getElementById('bt-help-text').style.display = 'block';
                document.getElementById('usb-help-text').style.display = 'none';
            } else {
                document.getElementById('bluetooth-section').style.display = 'none';
                document.getElementById('usb-section').style.display = 'block';
                document.getElementById('bt-help-text').style.display = 'none';
                document.getElementById('usb-help-text').style.display = 'block';
            }
        });
    });
    
    function getDisplayKeycode(keycode) {
        const useJisLayout = jisLayoutToggle.checked;
        if (useJisLayout && JIS_KEY_MAP[keycode]) { return JIS_KEY_MAP[keycode]; }
        if (KEYCODE_DISPLAY_MAP[keycode]) { return KEYCODE_DISPLAY_MAP[keycode]; }
        if (keycode.startsWith('HID_KEY_')) {
            const key = keycode.replace('HID_KEY_', '');
            if (key.startsWith('F') && !isNaN(key.substring(1))) { return key; }
            return key.length === 1 ? key : key.charAt(0);
        }
        return keycode;
    }
    
    function renderKeyboard() {
        const physicalLayoutJSON = [ [{"w":1.5},"sw1",{"x":12,"w":1.5},"sw62"], ["sw2","sw5","sw9","sw13","sw17","sw21","sw25","sw30","sw35","sw40","sw45","sw50","sw55","sw59","sw63"], [{"w":1.5},"sw3","sw6","sw10","sw14","sw18","sw22","sw26","sw31","sw36","sw41","sw46","sw51","sw56",{"w":1.5},"sw60"], [{"w":1.75},"sw4","sw7","sw11","sw15","sw19","sw23","sw27","sw32","sw37","sw42","sw47","sw52","sw57",{"w":1.25},"sw61"], [{"x":2.1},"sw8","sw12","sw16","sw20","sw24","sw28","sw33","sw38","sw43","sw48","sw53",{"w":1.5},"sw58"], [{"y":-0.5},"D10","D6"], [{"y":-0.5,"x":6.25,"w":2.5},"sw29","sw34","sw39","sw44","sw49","sw54"] ];
        keyboardContainer.innerHTML = '';
        const baseKeySize = 42; const baseGap = 5;
        physicalLayoutJSON.forEach(rowItems => {
            const row = document.createElement('div'); row.className = 'key-row';
            let currentProps = { w: 1, x: 0, y: 0 };
            rowItems.forEach(item => {
                if (typeof item === 'object' && item !== null) {
                    Object.assign(currentProps, item);
                    if (currentProps.y !== 0) { row.style.marginTop = `${currentProps.y * (baseKeySize + baseGap)}px`; }
                } else if (typeof item === 'string') {
                    const keyName = item;
                    const keyIndex = physical_layout_order_name.indexOf(keyName);
                    if (keyIndex === -1) { return; }
                    const keycode = keymapData[currentLayer][keyIndex];
                    const keyEl = document.createElement('div'); keyEl.className = 'key'; keyEl.dataset.index = keyIndex;
                    if (selectedKeyIndices.has(keyIndex)) { keyEl.classList.add('selected'); }
                    const codeEl = document.createElement('div'); codeEl.className = 'key-code';
                    if (isWaitingForKeypress && keyIndex === targetKeyIndexForCapture) {
                        keyEl.classList.add('waiting-capture');
                        codeEl.textContent = 'PRESS KEY';
                    } else {
                        codeEl.textContent = getDisplayKeycode(keycode);
                    }
                    keyEl.style.width = `${baseKeySize * currentProps.w + baseGap * (currentProps.w - 1)}px`;
                    if (currentProps.x > 0) { keyEl.style.marginLeft = `${currentProps.x * (baseKeySize + baseGap)}px`; }
                    const nameEl = document.createElement('div'); nameEl.className = 'key-name'; nameEl.textContent = keyName;
                    keyEl.appendChild(nameEl); keyEl.appendChild(codeEl);
                    keyEl.addEventListener('click', (e) => { const idx = parseInt(e.currentTarget.dataset.index); if (e.ctrlKey || e.metaKey) { selectedKeyIndices.has(idx) ? selectedKeyIndices.delete(idx) : selectedKeyIndices.add(idx); } else { selectedKeyIndices.clear(); selectedKeyIndices.add(idx); } renderKeyboard(); });
                    keyEl.addEventListener('dblclick', (e) => { const idx = parseInt(e.currentTarget.dataset.index); isWaitingForKeypress = true; targetKeyIndexForCapture = idx; renderKeyboard(); });
                    row.appendChild(keyEl);
                    currentProps = { w: 1, x: 0, y: currentProps.y };
                }
            });
            keyboardContainer.appendChild(row);
        });
    }

    function renderPalette() {
        tabButtonsContainer.innerHTML = ''; tabContentContainer.innerHTML = '';
        Object.keys(KEYCODES).forEach((category, idx) => {
            const btn = document.createElement('button'); btn.className = 'tab-button'; btn.textContent = category;
            if (idx === 0) { btn.classList.add('active'); paletteDescription.textContent = CATEGORY_DESCRIPTIONS[category]; }
            btn.addEventListener('click', () => { document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); btn.classList.add('active'); document.getElementById(`tab-${idx}`).classList.add('active'); paletteDescription.textContent = CATEGORY_DESCRIPTIONS[category]; });
            tabButtonsContainer.appendChild(btn);
            const content = document.createElement('div'); content.className = 'tab-content'; content.id = `tab-${idx}`;
            if (idx === 0) content.classList.add('active');
            const keysContainer = document.createElement('div'); keysContainer.className = 'palette-keys';
            KEYCODES[category].forEach(keycode => {
                const keyBtn = document.createElement('button'); keyBtn.className = 'palette-key'; keyBtn.textContent = getDisplayKeycode(keycode); keyBtn.title = keycode;
                keyBtn.addEventListener('mouseenter', () => { keyDescription.innerHTML = KEYCODE_DESCRIPTIONS[keycode] || '&nbsp;'; });
                keyBtn.addEventListener('mouseleave', () => { keyDescription.innerHTML = '&nbsp;'; });
                keyBtn.addEventListener('click', () => { if (selectedKeyIndices.size === 0) { alert('Please select at least one key on the layout first!'); return; } selectedKeyIndices.forEach(idx => { keymapData[currentLayer][idx] = keycode; }); renderKeyboard(); });
                keysContainer.appendChild(keyBtn);
            });
            content.appendChild(keysContainer);
            tabContentContainer.appendChild(content);
        });
    }

    function handleKeyCapture(e) {
        if (!isWaitingForKeypress) return;
        e.preventDefault();
        if (e.code === 'Escape') { isWaitingForKeypress = false; targetKeyIndexForCapture = null; renderKeyboard(); return; }
        const mappedKeycode = EVENT_CODE_TO_KEYCODE_MAP[e.code];
        if (mappedKeycode) { keymapData[currentLayer][targetKeyIndexForCapture] = mappedKeycode; } 
        else { console.warn(`Unsupported key captured: ${e.code}`); alert(`„Åì„ÅÆ„Ç≠„Éº (${e.code}) „ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ`); }
        isWaitingForKeypress = false; targetKeyIndexForCapture = null; renderKeyboard();
    }
    
    function generateFile() {
        const highSpeed = document.getElementById('MOUSE_HIGH_SPEED').value;
        const lowSpeed = document.getElementById('MOUSE_LOW_SPEED').value;
        const accel = document.getElementById('MOUSE_ACCEL_THRESHOLD').value;
        let fileContent = `// =========================================================================\n// ‚òÖ‚òÖ‚òÖ „ÅÇ„Å™„Åü„ÅåÁ∑®ÈõÜ„Åô„Çã„ÅÆ„ÅØ„ÄÅ„Åì„ÅÆ„Éï„Ç°„Ç§„É´„Å†„Åë! ‚òÖ‚òÖ‚òÖ\n// =========================================================================\n\n#include <Adafruit_TinyUSB.h>\n\n// --- „Ç¢„Éä„É≠„Ç∞„Çπ„ÉÜ„Ç£„ÉÉ„ÇØË®≠ÂÆö (ÈªÑÈáëË®≠ÂÆö) ---\n#define STICK_CENTER_X       470\n#define STICK_CENTER_Y       470\n#define STICK_DEADZONE       75\n#define MOUSE_HIGH_SPEED     ${highSpeed}f // ‚òÖ ÊúÄÈ´òÈÄüÂ∫¶\n#define MOUSE_LOW_SPEED      ${lowSpeed}f  // ‚òÖ ‰ΩéÈÄü„Çæ„Éº„É≥„ÅÆÊúÄÈ´òÈÄüÂ∫¶\n#define SMOOTHING_SAMPLES    2\n#define MOUSE_ACCEL_THRESHOLD ${accel} // ‚òÖ ‰ΩéÈÄü„Çæ„Éº„É≥„ÅåÁµÇ„Çè„ÇãÂÇæ„Åç\n\n// --- „Ç≠„Éº„Éû„Éà„É™„ÇØ„ÇπË®≠ÂÆö ---\n#define ROWS 8\n#define COLS 8\n#define LAYOUT_KEY_COUNT 65\n\n// --- „Ç´„Çπ„Çø„É†„Ç≠„Éº„Ç≥„Éº„ÉâÂÆöÁæ© ---\n#define KC_MS_UP         0x201\n#define KC_MS_DOWN       0x202\n#define KC_MS_LEFT       0x203\n#define KC_MS_RIGHT      0x204\n#define KC_MS_BTN1       0x205 // Â∑¶„ÇØ„É™„ÉÉ„ÇØ\n#define KC_MS_BTN2       0x206 // Âè≥„ÇØ„É™„ÉÉ„ÇØ\n#define KC_MS_BTN3       0x207 // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ\n#define KC_MS_BTN4       0x208 // Êàª„Çã\n#define KC_MS_BTN5       0x209 // ÈÄ≤„ÇÄ\n#define MOUSE_MOVE_SPEED 8\n#define KC_NO            0x000\n#define SW_USB_BT        0x401\n\n#define KC_RESET_KM      0x501\n#define KC_REBOOT_DEF    0x502\n\n// JP Keyboard specific keycodes\n#ifndef HID_KEY_INTERNATIONAL1\n  #define HID_KEY_INTERNATIONAL1 0x87\n#endif\n#ifndef HID_KEY_INTERNATIONAL3\n  #define HID_KEY_INTERNATIONAL3 0x89\n#endif\n#ifndef HID_KEY_LANG1\n  #define HID_KEY_LANG1 0x90\n#endif\n#ifndef HID_KEY_LANG2\n  #define HID_KEY_LANG2 0x91\n#endif\n\n// „É¨„Ç§„É§„ÉºÊ©üËÉΩÁî®\n#define NUM_LAYERS 2\n#define L_LOWER    0x301\n#define KC_TRNS    0x000\n\n\n// --- „Ç≠„Éº„Éû„ÉÉ„Éó„É¨„Ç§„Ç¢„Ç¶„ÉàÂÆöÁæ© ---\nconst uint16_t layout[NUM_LAYERS][LAYOUT_KEY_COUNT] = {\n`;
        keymapData.forEach((layer, layerIndex) => {
            fileContent += `  // [${layerIndex}] = ${layerIndex === 0 ? 'Default Layer' : 'Lower Layer (Fn„Ç≠„Éº„ÇíÊäº„Åó„Å¶„ÅÑ„ÇãÈñì)'}\n  {\n`;
            let logical_layer = layer;
            let keyIdx = 0;
            const createRow = (count, comment) => {
                fileContent += `    // ${comment}\n    `;
                fileContent += logical_layer.slice(keyIdx, keyIdx + count).join(', ') + ',\n';
                keyIdx += count;
            };
            const row_counts = { '1ÊÆµÁõÆ': 2, '2ÊÆµÁõÆ': 15, '3ÊÆµÁõÆ': 14, '4ÊÆµÁõÆ': 14, '5ÊÆµÁõÆ': 12, '6ÊÆµÁõÆ': 6, 'Áõ¥Êé•Êé•Á∂ö„Ç≠„Éº': 2 };
            for(const [comment, count] of Object.entries(row_counts)) {
                createRow(count, comment);
            }
            fileContent += '  }';
            fileContent += (layerIndex < keymapData.length - 1) ? ',\n\n' : '\n';
        });
        fileContent += `};\n`;
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'keymap.h';
        a.click();
        URL.revokeObjectURL(a.href);
    }
    
    function parseKeymapH(content) { 
        try { 
            const mouseHighMatch = content.match(/#define\s+MOUSE_HIGH_SPEED\s+([\d.]+)f?/); 
            const mouseLowMatch = content.match(/#define\s+MOUSE_LOW_SPEED\s+([\d.]+)f?/); 
            const mouseAccelMatch = content.match(/#define\s+MOUSE_ACCEL_THRESHOLD\s+(\d+)/); 
            if (mouseHighMatch) document.getElementById('MOUSE_HIGH_SPEED').value = mouseHighMatch[1]; 
            if (mouseLowMatch) document.getElementById('MOUSE_LOW_SPEED').value = mouseLowMatch[1]; 
            if (mouseAccelMatch) document.getElementById('MOUSE_ACCEL_THRESHOLD').value = mouseAccelMatch[1]; 
            const keymapMatch = content.match(/const\s+uint16_t\s+layout\[.*?\]\[.*?\]\s*=\s*{([\s\S]*?)};/); 
            if (!keymapMatch) throw new Error("Could not find 'layout' array."); 
            let layersContent = keymapMatch[1]; 
            layersContent = layersContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, ''); 
            const layerMatches = layersContent.match(/{[^}]+}/g); 
            if (!layerMatches || layerMatches.length < 2) throw new Error("Could not parse layers."); 
            keymapData = layerMatches.map(layerStr => { 
                const logical_keycodes = layerStr.replace(/{|}/g, '').split(',').map(s => s.trim()).filter(s => s.length > 0); 
                if (logical_keycodes.length !== 65) throw new Error(`Incorrect number of keys found in a layer: ${logical_keycodes.length}`); 
                return logical_keycodes; 
            }); 
            renderKeyboard(); 
            alert('Keymap loaded successfully!'); 
        } catch (error) { 
            alert('Error parsing file: ' + error.message); 
            console.error(error); 
        } 
    }
    
    async function connectBluetooth() { 
        if (!navigator.bluetooth) { 
            alert('„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØWeb Bluetooth„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇChrome/Edge„Çí„Åî‰ΩøÁî®„Åè„Å†„Åï„ÅÑ„ÄÇ'); 
            return; 
        } 
        try { 
            addDebugLog('BTÊé•Á∂öÈñãÂßã...'); 
            connectionStatus.textContent = 'Status: „Éá„Éê„Ç§„ÇπÈÅ∏Êäû‰∏≠...'; 
            const options = { 
                acceptAllDevices: false, 
                filters: [ { name: 'PotaKB' }, { namePrefix: 'Pota' } ], 
                optionalServices: [ KEYMAP_SERVICE_UUID, BATTERY_SERVICE_UUID ] 
            }; 
            bluetoothDevice = await navigator.bluetooth.requestDevice(options); 
            bluetoothDevice.addEventListener('gattserverdisconnected', () => { 
                connectionStatus.textContent = 'Status: ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü'; 
                keymapCharacteristic = null; 
                batteryCharacteristic = null;
                bluetoothDevice = null; 
                connectionType = null;
                saveToKeyboardButton.disabled = true; 
                loadFromKeyboardButton.disabled = true;
                connectButton.textContent = 'Connect via Bluetooth'; 
                connectButton.style.backgroundColor = '#007bff';
                stopBatteryMonitoring();
            }); 
            connectionStatus.textContent = 'Status: Êé•Á∂ö‰∏≠...'; 
            const server = await bluetoothDevice.gatt.connect(); 
            const keymapService = await server.getPrimaryService(KEYMAP_SERVICE_UUID); 
            keymapCharacteristic = await keymapService.getCharacteristic(KEYMAP_CHAR_UUID); 
            
            try {
                const batteryService = await server.getPrimaryService(BATTERY_SERVICE_UUID);
                batteryCharacteristic = await batteryService.getCharacteristic(BATTERY_CHAR_UUID);
                
                batteryCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value.getUint8(0);
                    batteryInfo.textContent = `üîã Battery: ${value}%`;
                });
                await batteryCharacteristic.startNotifications();
            } catch (e) {
                addDebugLog('„Éê„ÉÉ„ÉÜ„É™„ÉºÊÉÖÂ†±ÂèñÂæó‰∏çÂèØ');
            }
            
            connectionStatus.textContent = `Status: Êé•Á∂öÊàêÂäü! (${bluetoothDevice.name})`; 
            connectionType = 'bluetooth';
            saveToKeyboardButton.disabled = false; 
            loadFromKeyboardButton.disabled = false;
            connectButton.textContent = 'Êé•Á∂öÊ∏à„Åø'; 
            connectButton.style.backgroundColor = '#28a745';
            startBatteryMonitoring();
        } catch(error) { 
            connectionStatus.textContent = 'Status: Êé•Á∂öÂ§±Êïó - ' + error.message; 
            addDebugLog('BTÊé•Á∂ö„Ç®„É©„Éº: ' + error.message);
        } 
    }
    
    async function connectUSB() {
        if (!('serial' in navigator)) {
            alert('„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØWeb Serial API„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇChrome/Edge„Çí„Åî‰ΩøÁî®„Åè„Å†„Åï„ÅÑ„ÄÇ');
            return;
        }
        try {
            addDebugLog('USBÊé•Á∂öÈñãÂßã...');
            connectionStatus.textContent = 'Status: „Éù„Éº„ÉàÈÅ∏Êäû‰∏≠...';
            
            if (serialPort) {
                try {
                    await serialPort.close();
                } catch(e) {
                    addDebugLog('Êó¢Â≠ò„Éù„Éº„Éà„ÇØ„É≠„Éº„Ç∫: ' + e.message);
                }
                serialPort = null;
            }
            
            serialPort = await navigator.serial.requestPort();
            
            connectionStatus.textContent = 'Status: „Éù„Éº„Éà„Ç™„Éº„Éó„É≥‰∏≠...';
            addDebugLog('„Éú„Éº„É¨„Éº„Éà115200„ÅßÊé•Á∂öË©¶Ë°å...');
            
            await serialPort.open({ 
                baudRate: 115200,
                dataBits: 8,
                stopBits: 1,
                parity: 'none',
                bufferSize: 4096,
                flowControl: 'none'
            });
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            connectionStatus.textContent = 'Status: USBÊé•Á∂öÊàêÂäü!';
            connectionType = 'usb';
            saveToKeyboardButton.disabled = false;
            loadFromKeyboardButton.disabled = false;
            connectUsbButton.textContent = 'Êé•Á∂öÊ∏à„Åø';
            connectUsbButton.style.backgroundColor = '#28a745';
            addDebugLog('USBÊé•Á∂öÂÆå‰∫Ü');
            startBatteryMonitoring();
            
            serialPort.addEventListener('disconnect', () => {
                connectionStatus.textContent = 'Status: USBÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü';
                serialPort = null;
                connectionType = null;
                saveToKeyboardButton.disabled = true;
                loadFromKeyboardButton.disabled = true;
                connectUsbButton.textContent = 'Connect via USB Serial';
                connectUsbButton.style.backgroundColor = '#007bff';
                addDebugLog('USBÂàáÊñ≠');
                stopBatteryMonitoring();
            });
            
        } catch(error) {
            let errorMsg = error.message;
            let helpText = '';
            
            if (errorMsg.includes('Failed to open')) {
                helpText = '\n\nÂØæÂá¶Ê≥ï:\n1. Arduino IDE„Å™„Å©„ÅÆ„Ç∑„É™„Ç¢„É´„É¢„Éã„Çø„ÇíÈñâ„Åò„Å¶„Åè„Å†„Åï„ÅÑ\n2. ‰ªñ„ÅÆ„Ç¢„Éó„É™„Åß„Éù„Éº„Éà„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç\n3. „Éá„Éê„Ç§„Çπ„ÇíÂÜçÊé•Á∂ö„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ';
            }
            
            connectionStatus.textContent = 'Status: USBÊé•Á∂öÂ§±Êïó';
            addDebugLog('USBÊé•Á∂ö„Ç®„É©„Éº: ' + error.message);
            alert('USBÊé•Á∂ö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + errorMsg + helpText);
        }
    }
    
    async function loadFromKeyboard() {
        if (!keymapCharacteristic && !serialPort) {
            alert('ÂÖà„Å´„Éá„Éê„Ç§„Çπ„Å´Êé•Á∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ!');
            return;
        }
        
        try {
            connectionStatus.textContent = 'Status: Ë™≠„ÅøËæº„Åø‰∏≠...';
            let data;
            
            if (connectionType === 'bluetooth') {
                addDebugLog('BTÁµåÁî±„Åß„Ç≠„Éº„Éû„ÉÉ„ÉóË™≠„ÅøËæº„ÅøÈñãÂßã...');
                const dataValue = await keymapCharacteristic.readValue();
                data = dataValue;
                addDebugLog(`BTË™≠„ÅøËæº„ÅøÂÆå‰∫Ü: ${data.byteLength} bytes`);
                
                if (data.byteLength === 0) {
                    throw new Error('„Ç≠„Éº„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅåÁ©∫„Åß„Åô„ÄÇ„Ç≠„Éº„Éú„Éº„Éâ„ÇíÂÜçËµ∑Âãï„Åó„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                }
            } else if (connectionType === 'usb') {
                addDebugLog('USBÁµåÁî±„Åß„Ç≠„Éº„Éû„ÉÉ„ÉóË™≠„ÅøËæº„ÅøÈñãÂßã...');
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode('READ_KEYMAP\n'));
                writer.releaseLock();
                addDebugLog('READ_KEYMAP„Ç≥„Éû„É≥„ÉâÈÄÅ‰ø°ÂÆå‰∫Ü');
                
                await new Promise(resolve => setTimeout(resolve, 200));
                
                const reader = serialPort.readable.getReader();
                const chunks = [];
                const expectedBytes = 65 * 2 * 2;
                let totalReceived = 0;
                
                const timeout = setTimeout(() => {
                    reader.cancel();
                }, 5000);
                
                while (totalReceived < expectedBytes) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    totalReceived += value.length;
                    addDebugLog(`Âèó‰ø°‰∏≠: ${totalReceived}/${expectedBytes} bytes`);
                }
                clearTimeout(timeout);
                reader.releaseLock();
                
                const allData = new Uint8Array(totalReceived);
                let offset = 0;
                for (const chunk of chunks) {
                    allData.set(chunk, offset);
                    offset += chunk.length;
                }
                data = new DataView(allData.buffer);
                addDebugLog(`USBË™≠„ÅøËæº„ÅøÂÆå‰∫Ü: ${data.byteLength} bytes`);
            }
            
            if (data.byteLength < 260) {
                throw new Error(`„Éá„Éº„Çø„Çµ„Ç§„Ç∫„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô (${data.byteLength} bytes)`);
            }
            
            const newKeymapData = [[], []];
            for (let layer = 0; layer < 2; layer++) {
                for (let key = 0; key < 65; key++) {
                    const offset = (layer * 65 + key) * 2;
                    const value = data.getUint16(offset, true);
                    const keycode = VALUE_TO_KEYCODE_MAP[value] || 'KC_NO';
                    newKeymapData[layer].push(keycode);
                }
            }
            
            keymapData = newKeymapData;
            renderKeyboard();
            connectionStatus.textContent = 'Status: Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü!';
            alert('‚úì „Ç≠„Éº„Éû„ÉÉ„Éó„ÅÆË™≠„ÅøËæº„Åø„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü!');
            addDebugLog('„Ç≠„Éº„Éû„ÉÉ„ÉóË™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
        } catch(error) {
            alert('Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            connectionStatus.textContent = 'Status: ' + error.message;
            addDebugLog('Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: ' + error.message);
        }
    }
    
    async function saveToKeyboardViaBluetooth() { 
        if (!keymapCharacteristic && !serialPort) { 
            alert('ÂÖà„Å´„Éá„Éê„Ç§„Çπ„Å´Êé•Á∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ!'); 
            return; 
        } 
        let modeSwitchFound = false; 
        let resetKmFound = false; 
        let rebootDefFound = false; 
        keymapData.forEach(layer => { 
            layer.forEach(keycode => { 
                if (keycode === 'SW_USB_BT') modeSwitchFound = true; 
                if (keycode === 'KC_RESET_KM') resetKmFound = true; 
                if (keycode === 'KC_REBOOT_DEF') rebootDefFound = true; 
            }); 
        }); 
        if (!modeSwitchFound) { 
            alert("„Ç®„É©„Éº: 'Mode'„Ç≠„Éº (SW_USB_BT) „Åå„Ç≠„Éº„Éû„ÉÉ„Éó„Å´ÈÖçÁΩÆ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n\nUSB/BT„ÅÆÂàá„ÇäÊõø„Åà„Åå„Åß„Åç„Å™„Åè„Å™„Çã„Åü„ÇÅ„ÄÅÊõ∏„ÅçËæº„Åø„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ"); 
            return; 
        } 
        if (!resetKmFound && !rebootDefFound) { 
            if (!confirm("Ë≠¶Âëä:\n„Ç≠„Éº„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà„Åô„ÇãÊâãÊÆµ„ÅåÈÖçÁΩÆ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÆ„Åæ„ÅæÊõ∏„ÅçËæº„Åø„Åæ„Åô„Åã?\n\n- Reset KM („Éó„É≠„Éï„Ç°„Ç§„É´ÂÆåÂÖ®Ê∂àÂéª)\n- Boot DEF (‰∏ÄÊôÇÁöÑ„Å´ÂàùÊúüË®≠ÂÆö„ÅßËµ∑Âãï)")) { 
                return; 
            } 
        } 
        if (!confirm('„Ç≠„Éº„Éú„Éº„Éâ„Å´„Ç≠„Éº„Éû„ÉÉ„Éó„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åô„ÄÇÊõ∏„ÅçËæº„ÅøÂæå„ÄÅ„Ç≠„Éº„Éú„Éº„Éâ„ÅØËá™ÂãïÁöÑ„Å´ÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ\n\nÁ∂öË°å„Åó„Åæ„Åô„Åã?')) { 
            return; 
        } 
        try { 
            connectionStatus.textContent = 'Status: Êõ∏„ÅçËæº„Åø‰∏≠... (0%)'; 
            saveToKeyboardButton.disabled = true; 
            const data = convertKeymapToBytes(keymapData); 
            
            if (connectionType === 'bluetooth') {
                const CHUNK_SIZE = 20; 
                const totalChunks = Math.ceil(data.byteLength / CHUNK_SIZE); 
                for (let i = 0; i < totalChunks; i++) { 
                    const offset = i * CHUNK_SIZE; 
                    const chunk = data.slice(offset, offset + CHUNK_SIZE); 
                    await keymapCharacteristic.writeValueWithoutResponse(chunk); 
                    const progress = Math.round(((i + 1) / totalChunks) * 100); 
                    connectionStatus.textContent = `Status: Êõ∏„ÅçËæº„Åø‰∏≠... (${progress}%)`; 
                    await new Promise(resolve => setTimeout(resolve, 20)); 
                }
            } else if (connectionType === 'usb') {
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode('WRITE_KEYMAP\n'));
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const CHUNK_SIZE = 64;
                const totalChunks = Math.ceil(data.byteLength / CHUNK_SIZE);
                const dataArray = new Uint8Array(data);
                
                for (let i = 0; i < totalChunks; i++) {
                    const offset = i * CHUNK_SIZE;
                    const chunk = dataArray.slice(offset, offset + CHUNK_SIZE);
                    await writer.write(chunk);
                    const progress = Math.round(((i + 1) / totalChunks) * 100);
                    connectionStatus.textContent = `Status: Êõ∏„ÅçËæº„Åø‰∏≠... (${progress}%)`;
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                writer.releaseLock();
            }
            
            connectionStatus.textContent = 'Status: Êõ∏„ÅçËæº„ÅøÂÆå‰∫Ü! „Ç≠„Éº„Éú„Éº„Éâ„ÅåÂÜçËµ∑Âãï„Åó„Åæ„Åô'; 
            alert('‚úì „Ç≠„Éº„Éû„ÉÉ„Éó„ÅÆ‰øùÂ≠ò„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü!\n\n„Ç≠„Éº„Éú„Éº„Éâ„ÅåÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ\nÊï∞ÁßíÂæå„Å´ÂÜçÊé•Á∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'); 
            setTimeout(() => { 
                if (bluetoothDevice && bluetoothDevice.gatt.connected) { 
                    bluetoothDevice.gatt.disconnect(); 
                }
                if (serialPort) {
                    serialPort.close();
                    serialPort = null;
                    connectionType = null;
                    saveToKeyboardButton.disabled = true;
                    loadFromKeyboardButton.disabled = true;
                    connectUsbButton.textContent = 'Connect via USB Serial';
                    connectUsbButton.style.backgroundColor = '#007bff';
                }
                stopBatteryMonitoring();
            }, 1000); 
        } catch (error) { 
            alert('Êõ∏„ÅçËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message); 
            connectionStatus.textContent = 'Status: ' + error.message; 
            saveToKeyboardButton.disabled = false; 
            addDebugLog('Êõ∏„ÅçËæº„Åø„Ç®„É©„Éº: ' + error.message);
        } 
    }
    
    function convertKeymapToBytes(stringKeymap) { 
        const totalKeys = 2 * 65; 
        const buffer = new ArrayBuffer(totalKeys * 2); 
        const view = new DataView(buffer); 
        let offset = 0; 
        stringKeymap.forEach(layer => { 
            layer.forEach(keycodeStr => { 
                const value = KEYCODE_TO_VALUE_MAP[keycodeStr] !== undefined ? KEYCODE_TO_VALUE_MAP[keycodeStr] : 0; 
                view.setUint16(offset, value, true); 
                offset += 2; 
            }); 
        }); 
        return buffer; 
    }
    
    layerSelector.addEventListener('change', (e) => { currentLayer = parseInt(e.target.value); selectedKeyIndices.clear(); renderKeyboard(); });
    generateButton.addEventListener('click', generateFile);
    fileImporter.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { parseKeymapH(event.target.result); }; reader.readAsText(file); e.target.value = ''; });
    connectButton.addEventListener('click', connectBluetooth);
    connectUsbButton.addEventListener('click', connectUSB);
    saveToKeyboardButton.addEventListener('click', saveToKeyboardViaBluetooth);
    loadFromKeyboardButton.addEventListener('click', loadFromKeyboard);
    jisLayoutToggle.addEventListener('change', renderKeyboard);
    document.addEventListener('keydown', handleKeyCapture);

    renderPalette();
    renderKeyboard();
    
    document.getElementById('MOUSE_HIGH_SPEED').value = "75.0";
    document.getElementById('MOUSE_LOW_SPEED').value = "10.0";
    document.getElementById('MOUSE_ACCEL_THRESHOLD').value = "400";
    
    addDebugLog('„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ëµ∑ÂãïÂÆå‰∫Ü');
});
</script>
</body>
</html>